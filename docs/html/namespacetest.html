<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lazy Matrix: test Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lazy Matrix
   </div>
   <div id="projectbrief">A Single Header only Expression template based Matrix Library with basic Operations.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">test Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace holds the matrix library. It has been named so because it is meant for boost.uBLAS Google Summer of Code 2019 Proposal. It is the part of it's Competency test.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1add__expr.html">add_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a representation of node for add operation in the Abstract Syntax Tree.  <a href="classtest_1_1add__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtest_1_1dimension.html">dimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure holds the dimension of the Matrix. It overloads the basic operators.  <a href="structtest_1_1dimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1div__expr.html">div_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a representation of node for div operation in the Abstract Syntax Tree.  <a href="classtest_1_1div__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1expression.html">expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An template Expression class for a node in AST of lazy evalution.  <a href="classtest_1_1expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template class of the matrix. It is final and implements Curiously Recurring Templates Pattern. These matrices have immutable dimension and shapes will not change once created.  <a href="classtest_1_1matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1mul__expr.html">mul_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a representation of node for multiplication operation in the Abstract Syntax Tree.  <a href="classtest_1_1mul__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1sub__expr.html">sub_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a representation of node for subtraction operation in the Abstract Syntax Tree.  <a href="classtest_1_1sub__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a69806fc8b5b61fc4657f12f28ab961c0"><td class="memItemLeft" align="right" valign="top"><a id="a69806fc8b5b61fc4657f12f28ab961c0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_int</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; int &gt;</td></tr>
<tr class="separator:a69806fc8b5b61fc4657f12f28ab961c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d41fab07012aa4aeb82b7b64900ed5"><td class="memItemLeft" align="right" valign="top"><a id="ae0d41fab07012aa4aeb82b7b64900ed5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_long</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; long long &gt;</td></tr>
<tr class="separator:ae0d41fab07012aa4aeb82b7b64900ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf1cdf5f02172d62045d12c97feda7"><td class="memItemLeft" align="right" valign="top"><a id="ab9bf1cdf5f02172d62045d12c97feda7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_float</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; float &gt;</td></tr>
<tr class="separator:ab9bf1cdf5f02172d62045d12c97feda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad965d4aedb3467b9200b740eabd0285f"><td class="memItemLeft" align="right" valign="top"><a id="ad965d4aedb3467b9200b740eabd0285f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_double</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; double &gt;</td></tr>
<tr class="separator:ad965d4aedb3467b9200b740eabd0285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0695689353608a7e3dc3a28a79600c"><td class="memItemLeft" align="right" valign="top"><a id="a0d0695689353608a7e3dc3a28a79600c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_complex_float</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; std::complex&lt; float &gt; &gt;</td></tr>
<tr class="separator:a0d0695689353608a7e3dc3a28a79600c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c1a799a26028b63e44d7a3b9e7a9c"><td class="memItemLeft" align="right" valign="top"><a id="adb1c1a799a26028b63e44d7a3b9e7a9c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_complex_double</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt;</td></tr>
<tr class="separator:adb1c1a799a26028b63e44d7a3b9e7a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaf60b1607a89f0f5c159a6988461be"><td class="memItemLeft" align="right" valign="top"><a id="adfaf60b1607a89f0f5c159a6988461be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_complex_long</b> = <a class="el" href="classtest_1_1matrix.html">matrix</a>&lt; std::complex&lt; long long &gt; &gt;</td></tr>
<tr class="separator:adfaf60b1607a89f0f5c159a6988461be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4789bcc417e51b81dfa45a4e173a435c"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a4789bcc417e51b81dfa45a4e173a435c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetest.html#a4789bcc417e51b81dfa45a4e173a435c">operator==</a> (<a class="el" href="classtest_1_1expression.html">expression</a>&lt; E &gt; const &amp;lexpr, <a class="el" href="classtest_1_1expression.html">expression</a>&lt; E &gt; const &amp;expr)</td></tr>
<tr class="memdesc:a4789bcc417e51b81dfa45a4e173a435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator will check if the expression and the matrix have same value. It will cause the expression to be evalauted.  <a href="#a4789bcc417e51b81dfa45a4e173a435c">More...</a><br /></td></tr>
<tr class="separator:a4789bcc417e51b81dfa45a4e173a435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c910f0835e7bdf9b31af85264e4c3b2"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 &gt; </td></tr>
<tr class="memitem:a2c910f0835e7bdf9b31af85264e4c3b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtest_1_1add__expr.html">add_expr</a>&lt; E1, E2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetest.html#a2c910f0835e7bdf9b31af85264e4c3b2">operator+</a> (E1 const &amp;u, E2 const &amp;v)</td></tr>
<tr class="memdesc:a2c910f0835e7bdf9b31af85264e4c3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1add__expr.html" title="Constructs a representation of node for add operation in the Abstract Syntax Tree.">add_expr</a> object which can be evaluated to result it holds.  <a href="#a2c910f0835e7bdf9b31af85264e4c3b2">More...</a><br /></td></tr>
<tr class="separator:a2c910f0835e7bdf9b31af85264e4c3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949d3230afe0418cb028b829e9bf9a94"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 &gt; </td></tr>
<tr class="memitem:a949d3230afe0418cb028b829e9bf9a94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtest_1_1sub__expr.html">sub_expr</a>&lt; E1, E2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetest.html#a949d3230afe0418cb028b829e9bf9a94">operator-</a> (E1 const &amp;u, E2 const &amp;v)</td></tr>
<tr class="memdesc:a949d3230afe0418cb028b829e9bf9a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1sub__expr.html" title="Constructs a representation of node for subtraction operation in the Abstract Syntax Tree.">sub_expr</a> object which can be evaluated to result it holds.  <a href="#a949d3230afe0418cb028b829e9bf9a94">More...</a><br /></td></tr>
<tr class="separator:a949d3230afe0418cb028b829e9bf9a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ea9d576f5f2398586286d7f01fba47"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 &gt; </td></tr>
<tr class="memitem:a56ea9d576f5f2398586286d7f01fba47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtest_1_1mul__expr.html">mul_expr</a>&lt; E1, E2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetest.html#a56ea9d576f5f2398586286d7f01fba47">operator*</a> (E1 const &amp;u, E2 const &amp;v)</td></tr>
<tr class="memdesc:a56ea9d576f5f2398586286d7f01fba47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1mul__expr.html" title="Constructs a representation of node for multiplication operation in the Abstract Syntax Tree.">mul_expr</a> object which can be evaluated to result it holds.  <a href="#a56ea9d576f5f2398586286d7f01fba47">More...</a><br /></td></tr>
<tr class="separator:a56ea9d576f5f2398586286d7f01fba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de54d71b553c223f2b4619023186a17"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 &gt; </td></tr>
<tr class="memitem:a3de54d71b553c223f2b4619023186a17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtest_1_1div__expr.html">div_expr</a>&lt; E1, E2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetest.html#a3de54d71b553c223f2b4619023186a17">operator/</a> (E1 const &amp;u, E2 const &amp;v)</td></tr>
<tr class="memdesc:a3de54d71b553c223f2b4619023186a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1div__expr.html" title="Constructs a representation of node for div operation in the Abstract Syntax Tree.">div_expr</a> object which can be evaluated to result it holds.  <a href="#a3de54d71b553c223f2b4619023186a17">More...</a><br /></td></tr>
<tr class="separator:a3de54d71b553c223f2b4619023186a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f5af8ef66f6c5a47d2a5075a63fd3a"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 &gt; </td></tr>
<tr class="memitem:a66f5af8ef66f6c5a47d2a5075a63fd3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetest.html#a66f5af8ef66f6c5a47d2a5075a63fd3a">operator|</a> (E1 const &amp;u, E2 const &amp;v)</td></tr>
<tr class="memdesc:a66f5af8ef66f6c5a47d2a5075a63fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of two Matrices or expression and returns the result matrix immediately.  <a href="#a66f5af8ef66f6c5a47d2a5075a63fd3a">More...</a><br /></td></tr>
<tr class="separator:a66f5af8ef66f6c5a47d2a5075a63fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace holds the matrix library. It has been named so because it is meant for boost.uBLAS Google Summer of Code 2019 Proposal. It is the part of it's Competency test. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a56ea9d576f5f2398586286d7f01fba47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ea9d576f5f2398586286d7f01fba47">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtest_1_1mul__expr.html">mul_expr</a>&lt;E1, E2&gt; test::operator* </td>
          <td>(</td>
          <td class="paramtype">E1 const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1mul__expr.html" title="Constructs a representation of node for multiplication operation in the Abstract Syntax Tree.">mul_expr</a> object which can be evaluated to result it holds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E1</td><td>type of first operand </td></tr>
    <tr><td class="paramname">E2</td><td>type of second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the first argument </td></tr>
    <tr><td class="paramname">v</td><td>the second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mul_expr&lt;E1, E2&gt; a proxy that represents a add operation. </dd></dl>

</div>
</div>
<a id="a2c910f0835e7bdf9b31af85264e4c3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c910f0835e7bdf9b31af85264e4c3b2">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtest_1_1add__expr.html">add_expr</a>&lt;E1, E2&gt; test::operator+ </td>
          <td>(</td>
          <td class="paramtype">E1 const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1add__expr.html" title="Constructs a representation of node for add operation in the Abstract Syntax Tree.">add_expr</a> object which can be evaluated to result it holds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E1</td><td>type of first operand </td></tr>
    <tr><td class="paramname">E2</td><td>type of second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the first argument </td></tr>
    <tr><td class="paramname">v</td><td>the second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>add_expr&lt;E1, E2&gt; a proxy that represents a add operation. </dd></dl>

</div>
</div>
<a id="a949d3230afe0418cb028b829e9bf9a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949d3230afe0418cb028b829e9bf9a94">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtest_1_1sub__expr.html">sub_expr</a>&lt;E1, E2&gt; test::operator- </td>
          <td>(</td>
          <td class="paramtype">E1 const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1sub__expr.html" title="Constructs a representation of node for subtraction operation in the Abstract Syntax Tree.">sub_expr</a> object which can be evaluated to result it holds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E1</td><td>type of first operand </td></tr>
    <tr><td class="paramname">E2</td><td>type of second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the first argument </td></tr>
    <tr><td class="paramname">v</td><td>the second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sub_expr&lt;E1, E2&gt; a proxy that represents a add operation. </dd></dl>

</div>
</div>
<a id="a3de54d71b553c223f2b4619023186a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de54d71b553c223f2b4619023186a17">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtest_1_1div__expr.html">div_expr</a>&lt;E1, E2&gt; test::operator/ </td>
          <td>(</td>
          <td class="paramtype">E1 const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for Expression type. This operation returns a <a class="el" href="classtest_1_1div__expr.html" title="Constructs a representation of node for div operation in the Abstract Syntax Tree.">div_expr</a> object which can be evaluated to result it holds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E1</td><td>type of first operand </td></tr>
    <tr><td class="paramname">E2</td><td>type of second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the first argument </td></tr>
    <tr><td class="paramname">v</td><td>the second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>div_expr&lt;E1, E2&gt; a proxy that represents a add operation. </dd></dl>

</div>
</div>
<a id="a4789bcc417e51b81dfa45a4e173a435c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4789bcc417e51b81dfa45a4e173a435c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool test::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtest_1_1expression.html">expression</a>&lt; E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lexpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtest_1_1expression.html">expression</a>&lt; E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator will check if the expression and the matrix have same value. It will cause the expression to be evalauted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>the template parameter of expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expresssion type to evaluate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the expresssion's evaluated value is same as this </dd>
<dd>
false otherwiseThe == (equality) operator overload. Checks lexpr is equal to expr</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>the expression template </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lexpr</td><td>the left side expression </td></tr>
    <tr><td class="paramname">expr</td><td>the right side expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if they are same </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a66f5af8ef66f6c5a47d2a5075a63fd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f5af8ef66f6c5a47d2a5075a63fd3a">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto test::operator| </td>
          <td>(</td>
          <td class="paramtype">E1 const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the dot product of two Matrices or expression and returns the result matrix immediately. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E1</td><td>the type of first operand </td></tr>
    <tr><td class="paramname">E2</td><td>the type of second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the actual first argument </td></tr>
    <tr><td class="paramname">v</td><td>the actual second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lazy_matrix the result matrix. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
